<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>TCS: Module graph</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TCS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Module graph</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1graph_1_1GraphBuilder.html">pcl::graph::GraphBuilder&lt; PointT, Graph &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an abstract base class for building a BGL-compatible graph from a point cloud.  <a href="classpcl_1_1graph_1_1GraphBuilder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1graph_1_1NearestNeighborsGraphBuilder.html">pcl::graph::NearestNeighborsGraphBuilder&lt; PointT, Graph &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds a BGL graph representing an input dataset by using nearest neighbor search.  <a href="classpcl_1_1graph_1_1NearestNeighborsGraphBuilder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1graph_1_1OctreeAdjacencyGraphBuilder.html">pcl::graph::OctreeAdjacencyGraphBuilder&lt; PointT, Graph &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds a BGL graph representing an input dataset by using <a class="el" href="classpcl_1_1octree_1_1OctreePointCloudAdjacency.html" title="Octree pointcloud voxel class which maintains adjacency information for its voxels. ">octree::OctreePointCloudAdjacency</a>.  <a href="classpcl_1_1graph_1_1OctreeAdjacencyGraphBuilder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">pcl::graph::point_cloud_graph&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sibling of <code>boost::adjacency_list</code> with PCL points bundled in vertices and copy-free access to them as a PCL point cloud.  <a href="classpcl_1_1graph_1_1point__cloud__graph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1graph_1_1concepts_1_1PointCloudGraphConcept.html">pcl::graph::concepts::PointCloudGraphConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A PointCloudGraph is a graph that has PCL points bundled in vertices and can be viewed as a PCL point cloud (without data-copying).  <a href="classpcl_1_1graph_1_1concepts_1_1PointCloudGraphConcept.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad1acc84d14e81dd751883633759f3a2a"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:gad1acc84d14e81dd751883633759f3a2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph.html#gad1acc84d14e81dd751883633759f3a2a">pcl::graph::computeNormalsAndCurvatures</a> (Graph &amp;graph, bool neighborhood_1ring=false)</td></tr>
<tr class="memdesc:gad1acc84d14e81dd751883633759f3a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute normals and curvatures for all vertices in a graph.  <a href="#gad1acc84d14e81dd751883633759f3a2a">More...</a><br/></td></tr>
<tr class="separator:gad1acc84d14e81dd751883633759f3a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6681bddada66f5d10cc6da72c3f7a4c3"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ga6681bddada66f5d10cc6da72c3f7a4c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph.html#ga6681bddada66f5d10cc6da72c3f7a4c3">pcl::graph::computeSignedCurvatures</a> (Graph &amp;graph)</td></tr>
<tr class="memdesc:ga6681bddada66f5d10cc6da72c3f7a4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the type of curvature (concave/convex) for each vertex.  <a href="#ga6681bddada66f5d10cc6da72c3f7a4c3">More...</a><br/></td></tr>
<tr class="separator:ga6681bddada66f5d10cc6da72c3f7a4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad465f468e6e138d3735fb2fa0d6fa554"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:gad465f468e6e138d3735fb2fa0d6fa554"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph.html#gad465f468e6e138d3735fb2fa0d6fa554">pcl::graph::createSubgraphsFromConnectedComponents</a> (Graph &amp;graph, std::vector&lt; boost::reference_wrapper&lt; Graph &gt; &gt; &amp;subgraphs)</td></tr>
<tr class="memdesc:gad465f468e6e138d3735fb2fa0d6fa554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find connected components in a graph and create a subgraph for each of them.  <a href="#gad465f468e6e138d3735fb2fa0d6fa554">More...</a><br/></td></tr>
<tr class="separator:gad465f468e6e138d3735fb2fa0d6fa554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd8ba273c230e42bfbbef0dd71b1b75"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ga2dd8ba273c230e42bfbbef0dd71b1b75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph.html#ga2dd8ba273c230e42bfbbef0dd71b1b75">pcl::graph::createSubgraphsFromIndices</a> (Graph &amp;graph, const pcl::PointIndices &amp;indices, std::vector&lt; boost::reference_wrapper&lt; Graph &gt; &gt; &amp;subgraphs)</td></tr>
<tr class="memdesc:ga2dd8ba273c230e42bfbbef0dd71b1b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create two subgraphs of a given graph, one containing the points with the given indices, and the other containing the remaining points.  <a href="#ga2dd8ba273c230e42bfbbef0dd71b1b75">More...</a><br/></td></tr>
<tr class="separator:ga2dd8ba273c230e42bfbbef0dd71b1b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46b768c2fa95d5e3108500b6776a3b8"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:gaa46b768c2fa95d5e3108500b6776a3b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph.html#gaa46b768c2fa95d5e3108500b6776a3b8">pcl::graph::createSubgraphsFromIndices</a> (Graph &amp;graph, const std::vector&lt; pcl::PointIndices &gt; &amp;indices, std::vector&lt; boost::reference_wrapper&lt; Graph &gt; &gt; &amp;subgraphs)</td></tr>
<tr class="memdesc:gaa46b768c2fa95d5e3108500b6776a3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create subgraphs of a given graph containing vertices from a given indices vector.  <a href="#gaa46b768c2fa95d5e3108500b6776a3b8">More...</a><br/></td></tr>
<tr class="separator:gaa46b768c2fa95d5e3108500b6776a3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f2bfb5efe5e83e8c36b59ff5ed663e3"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ga3f2bfb5efe5e83e8c36b59ff5ed663e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph.html#ga3f2bfb5efe5e83e8c36b59ff5ed663e3">pcl::graph::smoothen</a> (Graph &amp;graph, float spatial_sigma, float influence_sigma)</td></tr>
<tr class="memdesc:ga3f2bfb5efe5e83e8c36b59ff5ed663e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply bilateral filtering to a given point cloud graph.  <a href="#ga3f2bfb5efe5e83e8c36b59ff5ed663e3">More...</a><br/></td></tr>
<tr class="separator:ga3f2bfb5efe5e83e8c36b59ff5ed663e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae269324deb0effed871890c7198877e5"><td class="memTemplParams" colspan="2">template&lt;PCG_PARAMS &gt; </td></tr>
<tr class="memitem:gae269324deb0effed871890c7198877e5"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointCloud&lt; P &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph.html#gae269324deb0effed871890c7198877e5">pcl::graph::point_cloud</a> (PCG &amp;g)</td></tr>
<tr class="memdesc:gae269324deb0effed871890c7198877e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the point cloud stored in a point cloud graph.  <a href="#gae269324deb0effed871890c7198877e5">More...</a><br/></td></tr>
<tr class="separator:gae269324deb0effed871890c7198877e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc378e1b3670b202c8192e39d3f7f33"><td class="memTemplParams" colspan="2">template&lt;PCG_PARAMS &gt; </td></tr>
<tr class="memitem:ga7cc378e1b3670b202c8192e39d3f7f33"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointCloud&lt; P &gt;::ConstPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph.html#ga7cc378e1b3670b202c8192e39d3f7f33">pcl::graph::point_cloud</a> (const PCG &amp;g)</td></tr>
<tr class="memdesc:ga7cc378e1b3670b202c8192e39d3f7f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the point cloud stored in a point cloud graph (const version).  <a href="#ga7cc378e1b3670b202c8192e39d3f7f33">More...</a><br/></td></tr>
<tr class="separator:ga7cc378e1b3670b202c8192e39d3f7f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1c7b61abc87d642f6c5c590bf4ad43d"><td class="memTemplParams" colspan="2">template&lt;PCG_PARAMS &gt; </td></tr>
<tr class="memitem:gae1c7b61abc87d642f6c5c590bf4ad43d"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointIndices::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph.html#gae1c7b61abc87d642f6c5c590bf4ad43d">pcl::graph::indices</a> (const PCG &amp;g)</td></tr>
<tr class="memdesc:gae1c7b61abc87d642f6c5c590bf4ad43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the indices of the points of the point cloud stored in a point cloud graph that actually belong to the graph.  <a href="#gae1c7b61abc87d642f6c5c590bf4ad43d">More...</a><br/></td></tr>
<tr class="separator:gae1c7b61abc87d642f6c5c590bf4ad43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba463e1be56d5c35c987402a4c0c220b"><td class="memTemplParams" colspan="2">template&lt;PCG_PARAMS &gt; </td></tr>
<tr class="memitem:gaba463e1be56d5c35c987402a4c0c220b"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointCloud&lt; P &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph.html#gaba463e1be56d5c35c987402a4c0c220b">pcl::graph::point_cloud</a> (boost::subgraph&lt; PCG &gt; &amp;g)</td></tr>
<tr class="memdesc:gaba463e1be56d5c35c987402a4c0c220b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the point cloud stored in a point cloud (sub)graph.  <a href="#gaba463e1be56d5c35c987402a4c0c220b">More...</a><br/></td></tr>
<tr class="separator:gaba463e1be56d5c35c987402a4c0c220b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb17e9bb564c58f9c957395c96aa387f"><td class="memTemplParams" colspan="2">template&lt;PCG_PARAMS &gt; </td></tr>
<tr class="memitem:gadb17e9bb564c58f9c957395c96aa387f"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointCloud&lt; P &gt;::ConstPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph.html#gadb17e9bb564c58f9c957395c96aa387f">pcl::graph::point_cloud</a> (const boost::subgraph&lt; PCG &gt; &amp;g)</td></tr>
<tr class="memdesc:gadb17e9bb564c58f9c957395c96aa387f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the point cloud stored in a point cloud (sub)graph (const version).  <a href="#gadb17e9bb564c58f9c957395c96aa387f">More...</a><br/></td></tr>
<tr class="separator:gadb17e9bb564c58f9c957395c96aa387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f370af9328d28148924b8744b451f43"><td class="memTemplParams" colspan="2">template&lt;PCG_PARAMS &gt; </td></tr>
<tr class="memitem:ga8f370af9328d28148924b8744b451f43"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointIndices::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph.html#ga8f370af9328d28148924b8744b451f43">pcl::graph::indices</a> (const boost::subgraph&lt; PCG &gt; &amp;g)</td></tr>
<tr class="memdesc:ga8f370af9328d28148924b8744b451f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the indices of the points of the point cloud stored in a point cloud (sub)graph that actually belong to the (sub)graph.  <a href="#ga8f370af9328d28148924b8744b451f43">More...</a><br/></td></tr>
<tr class="separator:ga8f370af9328d28148924b8744b451f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="secGraphPresentation"></a>
Overview</h1>
<p><b>pcl_graph</b> is an experimental library that aims to provide a common toolbox to aid development of graph-based 3D processing algorithms within the PCL framework. The library has a strong influence from <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/table_of_contents.html">Boost Graph Library</a> and relies on the concepts, classes, and algorithms found there.</p>
<p>At the heart of the library lies the <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">pcl::graph::point_cloud_graph</a> class, which may be considered to be a blend of a PCL point cloud and <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/adjacency_list.html">boost::adjacency_list</a> (the most common graph representation in BGL). As such, this class may be used in PCL algorithms where a point cloud input is expected, as well as in BGL algorithms, where a graph is needed.</p>
<p>The library contains means to build a weighted graph out of a raw point cloud. The first step of this process is to create the vertex and edge sets based on an input point cloud. This may be accomplished with either <a class="el" href="classpcl_1_1graph_1_1OctreeAdjacencyGraphBuilder.html" title="This class builds a BGL graph representing an input dataset by using octree::OctreePointCloudAdjacenc...">pcl::graph::OctreeAdjacencyGraphBuilder</a> or <a class="el" href="classpcl_1_1graph_1_1NearestNeighborsGraphBuilder.html" title="This class builds a BGL graph representing an input dataset by using nearest neighbor search...">pcl::graph::NearestNeighborsGraphBuilder</a>. The second step is to assign weights to the edges of the newly constructed graph. The <a class="el" href="structpcl_1_1graph_1_1weight_1_1weight__computer.html" title="A class that provides means to compute edge weights for a point cloud graph. ">pcl::graph::weight::weight_computer</a> class is a flexible and effecient, yet very experimental tool that may be used to achieve this goal.</p>
<p>Finally, the library provides a number of random functions (e.g. <a class="el" href="group__graph.html#ga2dd8ba273c230e42bfbbef0dd71b1b75" title="Create two subgraphs of a given graph, one containing the points with the given indices, and the other containing the remaining points. ">pcl::graph::createSubgraphsFromIndices()</a> or <a class="el" href="group__graph.html#gad1acc84d14e81dd751883633759f3a2a" title="Compute normals and curvatures for all vertices in a graph. ">pcl::graph::computeNormalsAndCurvatures()</a>) that may be helpful when dealing with point cloud graphs.</p>
<h1><a class="anchor" id="secGraphRequirements"></a>
Requirements</h1>
<ul>
<li>common</li>
<li>search</li>
<li>kdtree</li>
<li>octree</li>
<li>Boost &gt;= 1.53 </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad1acc84d14e81dd751883633759f3a2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::graph::computeNormalsAndCurvatures </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>neighborhood_1ring</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute normals and curvatures for all vertices in a graph. </p>
<p>For each vertex the function finds its 1- or 2-ring neighbors and uses pcl::computePointNormal() to calculate normal and curvature. It also flips the calculated normal towards 0,0,0 viewpoint.</p>
<p><code>Graph</code> has to be a model of <a class="el" href="classpcl_1_1graph_1_1concepts_1_1PointCloudGraphConcept.html" title="A PointCloudGraph is a graph that has PCL points bundled in vertices and can be viewed as a PCL point...">concepts::PointCloudGraphConcept</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">neighborhood_1ring</td><td>flag which controls whether 1- or 2- ring neighborhood is used. Default is 2-ring, which is slower, but produces smoother normals.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

</div>
</div>
<a class="anchor" id="ga6681bddada66f5d10cc6da72c3f7a4c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::graph::computeSignedCurvatures </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the type of curvature (concave/convex) for each vertex. </p>
<p>The type of curvature is expressed through the sign. Convex curvature is positive and concave curvature is negative. The absolute values of curvatures are not altered by this function.</p>
<p>TODO: add the formula.</p>
<p><code>Graph</code> has to be a model of <a class="el" href="classpcl_1_1graph_1_1concepts_1_1PointCloudGraphConcept.html" title="A PointCloudGraph is a graph that has PCL points bundled in vertices and can be viewed as a PCL point...">concepts::PointCloudGraphConcept</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

</div>
</div>
<a class="anchor" id="gad465f468e6e138d3735fb2fa0d6fa554"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t pcl::graph::createSubgraphsFromConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; boost::reference_wrapper&lt; Graph &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraphs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find connected components in a graph and create a subgraph for each of them. </p>
<p>Each created subgraph is filled with the vertices that belong to the corresponding connected component.</p>
<p>In order to allow creation of subgraphs, the graph type should be an instantiation of boost::subgraph template. Note that the graph is passed by non-const reference, because subgraph creation modifies the parent graph. Also, note that the created subgraphs are output as references wrapped with boost::reference_wrapper. The reason is that the factory function for subgraph creation in BGL returns newly created subgraphs by reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>an input graph </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subgraphs</td><td>a vector of references to created subgraps</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of connected components</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

</div>
</div>
<a class="anchor" id="ga2dd8ba273c230e42bfbbef0dd71b1b75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::graph::createSubgraphsFromIndices </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pcl::PointIndices &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; boost::reference_wrapper&lt; Graph &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraphs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create two subgraphs of a given graph, one containing the points with the given indices, and the other containing the remaining points. </p>
<p>In order to allow creation of subgraphs, the graph type should be an instantiation of boost::subgraph template. Note that the graph is passed by non-const reference, because subgraph creation modifies the parent graph. Also, note that the created subgraphs are output as references wrapped with boost::reference_wrapper. The reason is that the factory function for subgraph creation in BGL returns newly created subgraphs by reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>an input graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>indices of points to be inserted in the first subgraph </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subgraphs</td><td>a vector of references to created subgraps</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

</div>
</div>
<a class="anchor" id="gaa46b768c2fa95d5e3108500b6776a3b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::graph::createSubgraphsFromIndices </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; pcl::PointIndices &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; boost::reference_wrapper&lt; Graph &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraphs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create subgraphs of a given graph containing vertices from a given indices vector. </p>
<p>For each set of indices in the <code>indices</code> vector this function will create a subgraph containing corresponding vertices of the parent graph. An additional subgraph containing all the remaining vertices (not included in any other subgraph) will be created as well.</p>
<p>In order to allow creation of subgraphs, the graph type should be an instantiation of boost::subgraph template. Note that the graph is passed by non-const reference, because subgraph creation modifies the parent graph. Also, note that the created subgraphs are output as references wrapped with boost::reference_wrapper. The reason is that the factory function for subgraph creation in BGL returns newly created subgraphs by reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>an input graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>a vector of indices of points to be inserted in the subgraphs </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subgraphs</td><td>a vector of references to created subgraps</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

</div>
</div>
<a class="anchor" id="gae1c7b61abc87d642f6c5c590bf4ad43d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PCG_PARAMS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pcl::PointIndices::Ptr pcl::graph::indices </td>
          <td>(</td>
          <td class="paramtype">const PCG &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the indices of the points of the point cloud stored in a point cloud graph that actually belong to the graph. </p>
<p>Since <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> always contain all the points that it stores, this function always returs a vector with indices from <code>0</code> to <code>N-1</code>, where <code>N</code> is the number of vertices (points) in the graph.</p>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f370af9328d28148924b8744b451f43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PCG_PARAMS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pcl::PointIndices::Ptr pcl::graph::indices </td>
          <td>(</td>
          <td class="paramtype">const boost::subgraph&lt; PCG &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the indices of the points of the point cloud stored in a point cloud (sub)graph that actually belong to the (sub)graph. </p>
<p>A child subgraph contains only a subset of the vertices of the parent graph. This function provides a vector of indices of the vertices of the parent graph that belong to this subgraph as well. These vertex indices are valid point indices for the point cloud stored in the parent graph.</p>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

</div>
</div>
<a class="anchor" id="gae269324deb0effed871890c7198877e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PCG_PARAMS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pcl::PointCloud&lt;P&gt;::Ptr pcl::graph::point_cloud </td>
          <td>(</td>
          <td class="paramtype">PCG &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the point cloud stored in a point cloud graph. </p>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

</div>
</div>
<a class="anchor" id="ga7cc378e1b3670b202c8192e39d3f7f33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PCG_PARAMS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pcl::PointCloud&lt;P&gt;::ConstPtr pcl::graph::point_cloud </td>
          <td>(</td>
          <td class="paramtype">const PCG &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the point cloud stored in a point cloud graph (const version). </p>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

</div>
</div>
<a class="anchor" id="gaba463e1be56d5c35c987402a4c0c220b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PCG_PARAMS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pcl::PointCloud&lt;P&gt;::Ptr pcl::graph::point_cloud </td>
          <td>(</td>
          <td class="paramtype">boost::subgraph&lt; PCG &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the point cloud stored in a point cloud (sub)graph. </p>
<p>The behavior of this function will be different for root and child subgraphs. A root subgraph will return the point cloud stored in it, whereas a child subgraph will return the point cloud stored in its parent graph.</p>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

</div>
</div>
<a class="anchor" id="gadb17e9bb564c58f9c957395c96aa387f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PCG_PARAMS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pcl::PointCloud&lt;P&gt;::ConstPtr pcl::graph::point_cloud </td>
          <td>(</td>
          <td class="paramtype">const boost::subgraph&lt; PCG &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the point cloud stored in a point cloud (sub)graph (const version). </p>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f2bfb5efe5e83e8c36b59ff5ed663e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::graph::smoothen </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>spatial_sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>influence_sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply bilateral filtering to a given point cloud graph. </p>
<p><code>Graph</code> has to be a model of <a class="el" href="classpcl_1_1graph_1_1concepts_1_1PointCloudGraphConcept.html" title="A PointCloudGraph is a graph that has PCL points bundled in vertices and can be viewed as a PCL point...">concepts::PointCloudGraphConcept</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 26 2014 00:47:40 for TCS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
