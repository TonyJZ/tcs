<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>TCS: pcl::graph::point_cloud_graph&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TCS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pcl</b></li><li class="navelem"><b>graph</b></li><li class="navelem"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">point_cloud_graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classpcl_1_1graph_1_1point__cloud__graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcl::graph::point_cloud_graph&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__graph.html">Module graph</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A sibling of <code>boost::adjacency_list</code> with PCL points bundled in vertices and copy-free access to them as a PCL point cloud.  
 <a href="classpcl_1_1graph_1_1point__cloud__graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="point__cloud__graph_8h_source.html">point_cloud_graph.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcl::graph::point_cloud_graph&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpcl_1_1graph_1_1point__cloud__graph.png" usemap="#pcl::graph::point_cloud_graph&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt;_map" alt=""/>
  <map id="pcl::graph::point_cloud_graph&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt;_map" name="pcl::graph::point_cloud_graph&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad36eb0a5658a286e8a29485bce65002a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad36eb0a5658a286e8a29485bce65002a"></a>
typedef pcl::PointCloud<br class="typebreak"/>
&lt; PointT &gt;::Ptr&#160;</td><td class="memItemRight" valign="bottom"><b>graph_property_type</b></td></tr>
<tr class="separator:ad36eb0a5658a286e8a29485bce65002a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7f271010531225f0ab440dfcd4b517"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe7f271010531225f0ab440dfcd4b517"></a>
typedef pcl::PointCloud<br class="typebreak"/>
&lt; PointT &gt;::Ptr&#160;</td><td class="memItemRight" valign="bottom"><b>graph_bundled</b></td></tr>
<tr class="separator:abe7f271010531225f0ab440dfcd4b517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c20612b505315147b23d356bc038d9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c20612b505315147b23d356bc038d9a"></a>
typedef Base::vertex_property_type&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_property_type</b></td></tr>
<tr class="separator:a9c20612b505315147b23d356bc038d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475b84ec7dbdae7aa36812354dc845fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a475b84ec7dbdae7aa36812354dc845fd"></a>
typedef PointT&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_bundled</b></td></tr>
<tr class="separator:a475b84ec7dbdae7aa36812354dc845fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ccb2d5be32397d3ba3f9a935d17427"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73ccb2d5be32397d3ba3f9a935d17427"></a>
typedef Base::edge_property_type&#160;</td><td class="memItemRight" valign="bottom"><b>edge_property_type</b></td></tr>
<tr class="separator:a73ccb2d5be32397d3ba3f9a935d17427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029a8936b396bfa3e9ef6eb0d67a2fa2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a029a8936b396bfa3e9ef6eb0d67a2fa2"></a>
typedef Base::edge_bundled&#160;</td><td class="memItemRight" valign="bottom"><b>edge_bundled</b></td></tr>
<tr class="separator:a029a8936b396bfa3e9ef6eb0d67a2fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e106156e6c7bdb7154721937cd539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab45e106156e6c7bdb7154721937cd539"></a>
typedef Base::stored_vertex&#160;</td><td class="memItemRight" valign="bottom"><b>stored_vertex</b></td></tr>
<tr class="separator:ab45e106156e6c7bdb7154721937cd539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa987f4817f2b74d0ccbe48fed0b1d46f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa987f4817f2b74d0ccbe48fed0b1d46f"></a>
typedef Base::vertices_size_type&#160;</td><td class="memItemRight" valign="bottom"><b>vertices_size_type</b></td></tr>
<tr class="separator:aa987f4817f2b74d0ccbe48fed0b1d46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa1b0cef81921f6cc16809df1011dd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fa1b0cef81921f6cc16809df1011dd4"></a>
typedef Base::edges_size_type&#160;</td><td class="memItemRight" valign="bottom"><b>edges_size_type</b></td></tr>
<tr class="separator:a6fa1b0cef81921f6cc16809df1011dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22634b21a7d6d8724056516deb2ae1ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22634b21a7d6d8724056516deb2ae1ec"></a>
typedef Base::degree_size_type&#160;</td><td class="memItemRight" valign="bottom"><b>degree_size_type</b></td></tr>
<tr class="separator:a22634b21a7d6d8724056516deb2ae1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b4127f026396df924f0545fb148321"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90b4127f026396df924f0545fb148321"></a>
typedef Base::vertex_descriptor&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_descriptor</b></td></tr>
<tr class="separator:a90b4127f026396df924f0545fb148321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40246c638ab99c8e7aaee04f1f25fed6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40246c638ab99c8e7aaee04f1f25fed6"></a>
typedef Base::edge_descriptor&#160;</td><td class="memItemRight" valign="bottom"><b>edge_descriptor</b></td></tr>
<tr class="separator:a40246c638ab99c8e7aaee04f1f25fed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fee324ed4990303c926df2ace44581"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79fee324ed4990303c926df2ace44581"></a>
typedef OutEdgeListS&#160;</td><td class="memItemRight" valign="bottom"><b>out_edge_list_selector</b></td></tr>
<tr class="separator:a79fee324ed4990303c926df2ace44581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0bb9a4e7ec5bb0021ec51be79e9fd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec0bb9a4e7ec5bb0021ec51be79e9fd5"></a>
typedef boost::vecS&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_list_selector</b></td></tr>
<tr class="separator:aec0bb9a4e7ec5bb0021ec51be79e9fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c4573f89b8b0703d8682863c3055c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0c4573f89b8b0703d8682863c3055c4"></a>
typedef DirectedS&#160;</td><td class="memItemRight" valign="bottom"><b>directed_selector</b></td></tr>
<tr class="separator:ab0c4573f89b8b0703d8682863c3055c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a1b8c7d9b3fe23a31a3147c0e02897"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84a1b8c7d9b3fe23a31a3147c0e02897"></a>
typedef EdgeListS&#160;</td><td class="memItemRight" valign="bottom"><b>edge_list_selector</b></td></tr>
<tr class="separator:a84a1b8c7d9b3fe23a31a3147c0e02897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d13d253d4c74f5e75b786700d00cc8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d13d253d4c74f5e75b786700d00cc8d"></a>
typedef PointT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html#a0d13d253d4c74f5e75b786700d00cc8d">point_type</a></td></tr>
<tr class="memdesc:a0d13d253d4c74f5e75b786700d00cc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of PCL points bundled in graph vertices. <br/></td></tr>
<tr class="separator:a0d13d253d4c74f5e75b786700d00cc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a0f924ee302c4b8b046c1dd07ffd6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18a0f924ee302c4b8b046c1dd07ffd6f"></a>
typedef pcl::PointCloud&lt; PointT &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>point_cloud_type</b></td></tr>
<tr class="separator:a18a0f924ee302c4b8b046c1dd07ffd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665fb000caa4dd0fe93867cc7cb106f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a665fb000caa4dd0fe93867cc7cb106f7"></a>
typedef point_cloud_type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><b>point_cloud_ptr</b></td></tr>
<tr class="separator:a665fb000caa4dd0fe93867cc7cb106f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4856955ed8a3282a5c72a0fc884da7c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4856955ed8a3282a5c72a0fc884da7c0"></a>
typedef point_cloud_type::ConstPtr&#160;</td><td class="memItemRight" valign="bottom"><b>point_cloud_const_ptr</b></td></tr>
<tr class="separator:a4856955ed8a3282a5c72a0fc884da7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4ad3d9b6fd0f5e009703c853167dc921"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html#a4ad3d9b6fd0f5e009703c853167dc921">point_cloud_graph</a> (const point_cloud_ptr &amp;p=point_cloud_ptr(new point_cloud_type))</td></tr>
<tr class="memdesc:a4ad3d9b6fd0f5e009703c853167dc921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a graph based on existing point cloud.  <a href="#a4ad3d9b6fd0f5e009703c853167dc921">More...</a><br/></td></tr>
<tr class="separator:a4ad3d9b6fd0f5e009703c853167dc921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e5436a9f61b263dad1164caf92feab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html#a63e5436a9f61b263dad1164caf92feab">point_cloud_graph</a> (vertices_size_type num_vertices, const point_cloud_ptr &amp;p=point_cloud_ptr(new point_cloud_type))</td></tr>
<tr class="memdesc:a63e5436a9f61b263dad1164caf92feab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a graph with a given number of vertices.  <a href="#a63e5436a9f61b263dad1164caf92feab">More...</a><br/></td></tr>
<tr class="separator:a63e5436a9f61b263dad1164caf92feab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f51fc6d00d446267c2bb5d8b3647932"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html#a7f51fc6d00d446267c2bb5d8b3647932">point_cloud_graph</a> (const <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">point_cloud_graph</a> &amp;x)</td></tr>
<tr class="memdesc:a7f51fc6d00d446267c2bb5d8b3647932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a7f51fc6d00d446267c2bb5d8b3647932">More...</a><br/></td></tr>
<tr class="separator:a7f51fc6d00d446267c2bb5d8b3647932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10a0c012711c093dd210238b8b7ef4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">point_cloud_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html#ae10a0c012711c093dd210238b8b7ef4e">operator=</a> (const <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">point_cloud_graph</a> &amp;x)</td></tr>
<tr class="memdesc:ae10a0c012711c093dd210238b8b7ef4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ae10a0c012711c093dd210238b8b7ef4e">More...</a><br/></td></tr>
<tr class="separator:ae10a0c012711c093dd210238b8b7ef4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad365a56ee5831aa60ec68ecf6da577f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html#ad365a56ee5831aa60ec68ecf6da577f0">clear</a> ()</td></tr>
<tr class="memdesc:ad365a56ee5831aa60ec68ecf6da577f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all of the edges and vertices from the graph.  <a href="#ad365a56ee5831aa60ec68ecf6da577f0">More...</a><br/></td></tr>
<tr class="separator:ad365a56ee5831aa60ec68ecf6da577f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e76c147a0e3938a9c504e3c0d02689"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85e76c147a0e3938a9c504e3c0d02689"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>added_vertex</b> (vertex_descriptor vertex)</td></tr>
<tr class="separator:a85e76c147a0e3938a9c504e3c0d02689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6615350d98640a6652c7dfd5aac9ee4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6615350d98640a6652c7dfd5aac9ee4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removing_vertex</b> (vertex_descriptor vertex)</td></tr>
<tr class="separator:a6615350d98640a6652c7dfd5aac9ee4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to bundled vertex/edge properties.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The <code>operators[]</code>'s in this group may be used to access the data bundled in vertices and edges of the graph.</p>
<p>Implementation was directly copied from <code>adjacency_list</code>.</p>
<p>Note that there is no operator access to the GraphProperty as there is no such thing in <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> (see the corresponding section in the class description for more information). </p>
</div></td></tr>
<tr class="memitem:ab2956c6986a69126857e0007cbf1d49a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2956c6986a69126857e0007cbf1d49a"></a>
vertex_bundled &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (vertex_descriptor v)</td></tr>
<tr class="separator:ab2956c6986a69126857e0007cbf1d49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9771d115b318ddb20dd3d91e6039f860"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9771d115b318ddb20dd3d91e6039f860"></a>
const vertex_bundled &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (vertex_descriptor v) const </td></tr>
<tr class="separator:a9771d115b318ddb20dd3d91e6039f860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436bee68798d392413386056f60d85fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a436bee68798d392413386056f60d85fc"></a>
edge_bundled &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (edge_descriptor e)</td></tr>
<tr class="separator:a436bee68798d392413386056f60d85fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a51583b018118ee5f0f6260ae61821"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0a51583b018118ee5f0f6260ae61821"></a>
const edge_bundled &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (edge_descriptor e) const </td></tr>
<tr class="separator:ae0a51583b018118ee5f0f6260ae61821"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab26465461cb117365b20a63a44ba0ca7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab26465461cb117365b20a63a44ba0ca7"></a>
point_cloud_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html#ab26465461cb117365b20a63a44ba0ca7">m_point_cloud</a></td></tr>
<tr class="memdesc:ab26465461cb117365b20a63a44ba0ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the internal cloud data. <br/></td></tr>
<tr class="separator:ab26465461cb117365b20a63a44ba0ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PointT, typename OutEdgeListS = boost::vecS, typename DirectedS = boost::undirectedS, typename VertexProperty = boost::no_property, typename EdgeProperty = boost::no_property, typename EdgeListS = boost::listS&gt;<br/>
class pcl::graph::point_cloud_graph&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt;</h3>

<p>A sibling of <code>boost::adjacency_list</code> with PCL points bundled in vertices and copy-free access to them as a PCL point cloud. </p>
<h1>Motivation</h1>
<p>Boost Graph Library has a concept of <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/bundles.html">bundled properties</a>, i.e. custom data types that may be stored in graph vertices and conveniently accessed with <code>operator[]</code>. In the context of PCL it makes a lot of sense to have PCL points bundled in graph vertices. The following specialization of <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/adjacency_list.html" title="adjacency_list">boost::adjacency_list</a> achieves that:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span></div>
<div class="line">  boost::adjacency_list&lt;</div>
<div class="line">    boost::vecS          <span class="comment">// Represent edge-list with std::vector</span></div>
<div class="line">  , boost::vecS          <span class="comment">// Represent vertex-list with std::vector</span></div>
<div class="line">  , boost::undirectedS   <span class="comment">// Undirected graph</span></div>
<div class="line">  , pcl::PointXYZ&gt;       <span class="comment">// Bundle XYZ points in vertices</span></div>
<div class="line">Graph</div>
</div><!-- fragment --><p>A graph-based algorithm can easily access points associated with graph vertices:</p>
<div class="fragment"><div class="line">Graph graph;</div>
<div class="line">Graph::vertex_descriptor v1 = boost::add_vertex (graph);</div>
<div class="line">Graph::vertex_descriptor v2 = boost::add_vertex (graph);</div>
<div class="line">graph[v1] = pcl::PointXYZ (1, 2, 3);</div>
<div class="line">graph[v2].x = graph[v1].x;</div>
</div><!-- fragment --><p>The problem though is that there is no efficient way to put the point cloud data inside the graph and retrieve it back. Suppose that in some application there is a point cloud that should first be filtered using some PCL tools (e.g. PassthroughFilter), then a graph-based algorithm should be applied to it, and finally some more processing using PCL tools is required. The user will need to copy all the points of the original point cloud one-by-one to the graph, run the algorithm, and then copy it back one-by-one again.</p>
<h1>Solution</h1>
<p><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> resolves this issue by storing bundled points internally as a PCL point cloud. In fact, it stores a shared pointer to a point cloud, so input and output of points is really copy-free. One can create a new graph based on an existing point cloud:</p>
<div class="fragment"><div class="line"><span class="comment">// Create a point cloud with 10 points</span></div>
<div class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud (<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt; (10, 1);</div>
<div class="line"><span class="comment">// Create a graph based on the cloud</span></div>
<div class="line"><a class="code" href="classpcl_1_1graph_1_1point__cloud__graph.html">pcl::graph::point_cloud_graph&lt;pcl::PointXYZ&gt;</a> graph (cloud);</div>
<div class="line"><span class="comment">// The graph will have a vertex for each point of the original cloud</span></div>
<div class="line">assert (10 == boost::num_vertices (graph));</div>
<div class="line"><span class="comment">// The points may be accessed using operator[]</span></div>
<div class="line">graph[1].x = 14;</div>
<div class="line"><span class="comment">// The graph shares data with the original point cloud, so modifying a bundled point</span></div>
<div class="line"><span class="comment">// changes the corresponding point in the original cloud</span></div>
<div class="line">assert (14 == cloud-&gt;points[1].x);</div>
</div><!-- fragment --><p>The internal point cloud may be accessed using <code>boost::point_cloud (Graph&amp; g)</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Perform some graph-based algorithm on point cloud graph</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// Retrieve the bundled data as a point cloud</span></div>
<div class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr data = <a class="code" href="group__graph.html#gae269324deb0effed871890c7198877e5">boost::point_cloud</a> (graph);</div>
<div class="line"><span class="comment">// Continue to work with the data</span></div>
<div class="line">pcl::io::savePCDFile (<span class="stringliteral">&quot;output.pcd&quot;</span>, *data);</div>
</div><!-- fragment --><p>Despite the fact that the point data are stored in a PCL point cloud, all the standard BGL features associated with bundled properties are supported, including <code>operator[]</code> and <code>get</code>/<code>put</code> access.</p>
<h2>Comparison with <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/adjacency_list.html" title="adjacency_list">boost::adjacency_list</a></h2>
<p><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> uses the same back-bone implementation as <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/adjacency_list.html" title="adjacency_list">boost::adjacency_list</a> and therefore models the same concepts and may be used everywhere <code>boost::adjacency_list</code> could. In particular, the very same functions could be used to add and remove vertices, access properties, iterate over edges, etc.</p>
<p>As <code>boost::adjacency_list</code>, <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> allows to configure itself with a number of template parameters. They are almost the same as in <code>boost::adjacency_list</code>, though there are several differences:</p>
<ol type="1">
<li><p class="startli">There is a required template parameter <code>PointT</code> which allows the user to select the type of PCL points to be bundled in graph vertices;</p>
<p class="startli">Note that the <code>VertexProperty</code> parameter is still available for the user, so it is possible to attach as many <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/using_adjacency_list.html#sec:adjacency-list-properties">internal properties</a> (such as <code>vertex_color_t</code>) as needed.</p>
</li>
<li>The default value for <code>Directed</code> parameter is changed to <code>undirectedS</code> since it is more relevant in the context of point cloud processing;</li>
<li><p class="startli">The vertex-list of the graph is constrained to be <code>std::vector</code>. The user has no control over it as there is no <code>VertexList</code> template parameter;</p>
<p class="startli">The choice of the container for the vertex-list determines the space complexity of the graph structure, as well as the time complexity of the various graph operations, see <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/using_adjacency_list.html#sec:choosing-graph-type">using boost::adjacency_list</a> for a more detailed discussion. In the case of <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> the vertex bundled properties (PCL points) are stored in a PCL point cloud (which has <code>std::vector</code> behind the scenes), so it is only logical to have <code>std::vector</code> as the container type for the vertex-list itself.</p>
</li>
<li><p class="startli">There is no <code>GraphProperty</code> template parameter.</p>
<p class="startli"><a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/adjacency_list.html" title="adjacency_list">boost::adjacency_list</a> provides a facility to store an arbitrary piece of data associated with the graph as a whole (graph property). While being useful in certain cases, we do not consider this as a vital feature and have sacrificed it to support <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/subgraph.html" title="subgraph">boost::subgraph</a>. For more details please refer to the section about <code>boost::subgraph</code> below.</p>
</li>
</ol>
<h2>Compatibility with <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/subgraph.html" title="subgraph">boost::subgraph</a></h2>
<p><code>boost::subgraph</code> provides a convenient mechanism to keep track of a graph and its induced subgraphs. Two issues have been accounted for in order to allow smooth inter-operation between <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> and <code>boost::subgraph</code>.</p>
<h3>Fixed interface</h3>
<p><code>boost::subgraph</code> is a template class that is <em>wrapped around</em> a graph class rather than a class that <em>inherits</em> from a graph class. Therefore if we want it to be possible to use <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> either way (plain or wrapped by <code>boost::subgraph</code>), we have to limit ourselves to the interface exposed by <code>boost::subgraph</code>. In particular, we can not have a PCL point cloud-based constructor for <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> because (for apparent reasons) <code>boost::subgraph</code> does not have it. However, the ability to construct a <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> from an existing PCL point cloud is an essential feature. We noted that <code>boost::subgraph</code> has a GraphProperty-based constructor that could be re-used as a desired PCL point cloud-based constructor if we alias GraphProperty to PCL point cloud. Thus GraphProperty is used to support internal mechanics of <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> and is no longer available to the user.</p>
<h3>Lack of internal storage for points</h3>
<p>Recall that <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> stores the points bundled in its vertices inside a PCL point cloud. It could be conveniently retrieved using <code>boost::point_cloud (Graph&amp; g)</code> and then used in PCL algorithms. <code>boost::subgraph</code>, however, is designed in such a way that it stores the indices of the vertices and edges of the parent (root) graph that belong to it, but not the data associated with these vertices and edges. In other words, a hierarchy of subgraphs (each of which represents a particular subset of vertices and edges of the root graph) shares common vertex/edge data, and all these data are contained inside the root graph. Consequently, there does not exist a PCL point cloud for each subgraph, but rather a single PCL point cloud for the root graph. This raises a question as of how the <code>boost::point_cloud (Subgraph&amp; g)</code> function should be implemented.</p>
<p>One option is to construct a new PCL point cloud and fill it with subgraph's points. This, however, would be inconsistent with the behavior of <code>boost::point_cloud (Graph&amp; g)</code>, which simply returns a pointer (meaning it is <em>O(1)</em> operation) that could be used to read and modify the points of the graph. Luckily, working with subsets of point clouds is such a common task in the PCL world that pcl::PCLBase class (which lies at the top of the hierarchy of PCL algorithms) has a means for the user to supply an input point cloud <em>and</em> a vector of indices to which the processing should be limited to. Therefore, we decided that <code>boost::point_cloud (Subgraph&amp; g)</code> should return the PCL point cloud of its root graph (that is, the whole set of points), and there should be an auxiliary function <code>boost::indices (Subgraph&amp; g)</code> that returns indices of the points that belong to the subgraph.</p>
<hr/>
<h1>Specification</h1>
<p>As was noted, <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> is virtually the same as <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/adjacency_list.html" title="adjacency_list">boost::adjacency_list</a>. Please refer to its documentation. The specifications below only highlight the differences.</p>
<h2>Template parameters</h2>
<table class="doxtable">
<tr>
<th>Parameter </th><th>Description </th><th>Default  </th></tr>
<tr>
<td>PointT </td><td>Type of PCL points bundled in graph vertices </td><td>&ndash; </td></tr>
<tr>
<td>OutEdgeList </td><td>Selector for the container used to represent the edge-list for each of the vertices </td><td><code>vecS</code> </td></tr>
<tr>
<td>Directed </td><td>Selector to choose whether the graph is directed/undirected/bidirectional </td><td><code>undirectedS</code> </td></tr>
<tr>
<td>VertexProperty </td><td>For specifying internal vertex property storage (apart from bundled points) </td><td><code>no_property</code> </td></tr>
<tr>
<td>EdgeProperty </td><td>For specifying internal edge property storage </td><td><code>no_property</code> </td></tr>
<tr>
<td>EdgeList </td><td>Selector for the container used to represent the edge-list for the graph </td><td><code>listS</code> </td></tr>
</table>
<h2>Model of</h2>
<p>PointCloudGraph, <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/VertexAndEdgeListGraph.html">VertexAndEdgeListGraph</a>, <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/MutablePropertyGraph.html">VertexMutablePropertyGraph</a>, <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/MutablePropertyGraph.html">EdgeMutablePropertyGraph</a>, <a href="http://www.boost.org/doc/libs/1_55_0/libs/utility/CopyConstructible.html">CopyConstructible</a>, <a href="http://www.boost.org/doc/libs/1_55_0/libs/utility/Assignable.html">Assignable</a></p>
<p>Probably it could also support <a href="http://www.boost.org/doc/libs/1_55_0/libs/serialization/doc/index.html">Serializable</a>, however this option has not been explored.</p>
<h2>Associated types</h2>
<p><a class="el" href="structpcl_1_1graph_1_1point__cloud__graph__traits.html" title="Traits struct to access the types associated with point_cloud_graph. ">point_cloud_graph_traits</a> structure provides a means to access the type of points bundled in the <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> and, for convenience, the types of PCL point cloud and shared pointer to PCL point cloud of those points.</p>
<h2>Non-member functions</h2>
<div class="fragment"><div class="line"><span class="keyword">typename</span> pcl::PointCloud&lt;PointT&gt;::Ptr</div>
<div class="line"><a class="code" href="group__graph.html#gae269324deb0effed871890c7198877e5">pcl::graph::point_cloud</a> (point_cloud_graph&lt;PointT&gt;&amp; g);</div>
</div><!-- fragment --><p>Return a shared pointer to the PCL point cloud stored internally. There are both <code>const</code> and <code>non-const</code> versions.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> pcl::PointCloud&lt;PointT&gt;::Ptr</div>
<div class="line"><a class="code" href="group__graph.html#gae269324deb0effed871890c7198877e5">pcl::graph::point_cloud</a> (boost::subgraph&lt;point_cloud_graph&lt;PointT&gt;&gt;&amp; g);</div>
</div><!-- fragment --><p>Return a shared pointer to the PCL point cloud stored in the <em>root</em> graph. There are both <code>const</code> and <code>non-const</code> versions.</p>
<div class="fragment"><div class="line">pcl::PointIndices::Ptr</div>
<div class="line"><a class="code" href="group__graph.html#gae1c7b61abc87d642f6c5c590bf4ad43d">pcl::graph::indices</a> (point_cloud_graph&lt;PointT&gt;&amp; g);</div>
</div><!-- fragment --><p>Return a shared pointer to a vector of indices of the points that belong to this graph. Since <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html" title="A sibling of boost::adjacency_list with PCL points bundled in vertices and copy-free access to them a...">point_cloud_graph</a> is a complete graph (i.e. it is not a subgraph of some other graph), the returned indices are guaranteed to be *[0..N-1]*, where <em>N</em> is the number of vertices. There are both <code>const</code>- and <code>non-const</code>- versions.</p>
<div class="fragment"><div class="line">pcl::PointIndices::Ptr</div>
<div class="line"><a class="code" href="group__graph.html#gae1c7b61abc87d642f6c5c590bf4ad43d">pcl::graph::indices</a> (boost::subgraph&lt;point_cloud_graph&lt;PointT&gt;&gt;&amp; g);</div>
</div><!-- fragment --><p>Return a shared pointer to a vector of indices of the points of the root graph that belong to this subgraph. There are both <code>const</code>- and <code>non-const</code>- versions.</p>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4ad3d9b6fd0f5e009703c853167dc921"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename OutEdgeListS  = boost::vecS, typename DirectedS  = boost::undirectedS, typename VertexProperty  = boost::no_property, typename EdgeProperty  = boost::no_property, typename EdgeListS  = boost::listS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">pcl::graph::point_cloud_graph</a>&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt;::<a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">point_cloud_graph</a> </td>
          <td>(</td>
          <td class="paramtype">const point_cloud_ptr &amp;&#160;</td>
          <td class="paramname"><em>p</em> = <code>point_cloud_ptr&#160;(new&#160;point_cloud_type)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a graph based on existing point cloud. </p>
<p>The graph will have the same amount of vertices as the input point cloud has. The shared pointer will be stored internally so that the graph retains access to the point data.</p>
<p>If the cloud is not given, then a new empty cloud will be created. </p>

</div>
</div>
<a class="anchor" id="a63e5436a9f61b263dad1164caf92feab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename OutEdgeListS  = boost::vecS, typename DirectedS  = boost::undirectedS, typename VertexProperty  = boost::no_property, typename EdgeProperty  = boost::no_property, typename EdgeListS  = boost::listS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">pcl::graph::point_cloud_graph</a>&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt;::<a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">point_cloud_graph</a> </td>
          <td>(</td>
          <td class="paramtype">vertices_size_type&#160;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point_cloud_ptr &amp;&#160;</td>
          <td class="paramname"><em>p</em> = <code>point_cloud_ptr&#160;(new&#160;point_cloud_type)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a graph with a given number of vertices. </p>
<p>This constructor will create a new point cloud to store point data. The second parameter is completely ignored and is provided only to have the same interface as <code>adjacency_list</code>. </p>

</div>
</div>
<a class="anchor" id="a7f51fc6d00d446267c2bb5d8b3647932"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename OutEdgeListS  = boost::vecS, typename DirectedS  = boost::undirectedS, typename VertexProperty  = boost::no_property, typename EdgeProperty  = boost::no_property, typename EdgeListS  = boost::listS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">pcl::graph::point_cloud_graph</a>&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt;::<a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">point_cloud_graph</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">point_cloud_graph</a>&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Acts just like the standard copy constructor of <code>adjacency_list</code>, i.e. copies vertex and edge set along with associated properties. Note that a <b>deep copy</b> of the underlying point cloud is made.</p>
<p>This costructor reuses assignment operator. An alternative approach would be to use the copy constructor of the base class and then copy over the underlying point cloud, however the problem is that the base constructor uses <code>boost::add_vertex</code> function, which will attempt to push points to the point cloud, although it will not be initialized yet at that point in time (hence segfault). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad365a56ee5831aa60ec68ecf6da577f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename OutEdgeListS  = boost::vecS, typename DirectedS  = boost::undirectedS, typename VertexProperty  = boost::no_property, typename EdgeProperty  = boost::no_property, typename EdgeListS  = boost::listS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">pcl::graph::point_cloud_graph</a>&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all of the edges and vertices from the graph. </p>
<p>Note that it vipes the underlying point cloud as well. </p>

</div>
</div>
<a class="anchor" id="ae10a0c012711c093dd210238b8b7ef4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename OutEdgeListS  = boost::vecS, typename DirectedS  = boost::undirectedS, typename VertexProperty  = boost::no_property, typename EdgeProperty  = boost::no_property, typename EdgeListS  = boost::listS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">point_cloud_graph</a>&amp; <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">pcl::graph::point_cloud_graph</a>&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">point_cloud_graph</a>&lt; PointT, OutEdgeListS, DirectedS, VertexProperty, EdgeProperty, EdgeListS &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Acts just like the standard assignment operator of <code>adjacency_list</code>, i.e. copies vertex and edge set along with associated properties. Note that a <b>deep copy</b> of the underlying point cloud is made. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="point__cloud__graph_8h_source.html">point_cloud_graph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 20 2014 22:40:24 for TCS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
